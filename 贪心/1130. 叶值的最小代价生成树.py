# ①题目中给出的中序遍历顺序的叶节点数组，说白了就是叶节点从左到右的数组，而且这个过程非常像哈夫曼编码，但是略有不同。 （1）给我们的节点不可以随意选择，我们只可以选择相邻的两个节点 （2）两个节点合并的方式也不是两数之和，而是用其中最大的一个数来表示
#
# 例如{6,2,4},我们选择{6,2}合并，则下一步集合变成{6,4}，若选择{2,4}合并，则下一步集合变成{6,4}
#
# ②题目中给出的数据都是正数，所以两个数的最小乘积必然是选择数组中最小的两个数（且这两个数相邻），并且这种局部最优算法会继续优化我们后续的算法，因为我们选择是两个最小的正数，而合并的时候虽然选择的是两个数中最大的一个，但这个数仍然是整个数组最小的数，也就是我们做出的贪心选择，下一步也将是最优的
#
# ③其实最难的还是如何证明这个贪心的正确性，贪心算法的正确性一直都是最难证明的，很多人能想到但是不敢写


class Solution(object):
    def mctFromLeafValues(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        ans = 0
        while len(arr) > 1:
            # mn 记录的最小值
            # del_i 记录删除元素的下标
            mn = float('inf')
            del_i = 0
            for i in range(len(arr)-1):
                if arr[i]*arr[i+1] < mn:
                    mn = arr[i]*arr[i+1]
                    del_i = i + 1 if arr[i] > arr[i+1] else i
            ans += mn
            del arr[del_i]
        return ans

# 1130. 叶值的最小代价生成树.py