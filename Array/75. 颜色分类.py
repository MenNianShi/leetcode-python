# 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
#
# 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
#
# 注意:
# 不能使用代码库中的排序函数来解决这道题。
#
# 示例:
#
# 输入: [2,0,2,1,1,0]
# 输出: [0,0,1,1,2,2]
#
#
# 方法一需要进行两次遍历，那么我们是否可以仅使用一次遍历呢？我们可以额外使用一个指针，即使用两个指针分别用来交换 0 和 1。
# 具体地，我们用指针 p_0 来交换 0，p_1来交换 1，初始值都为 0。当我们从左向右遍历整个数组时：
# 如果找到了 1，那么将其与nums[p 1] 进行交换，并将 p_1向后移动一个位置，这与方法一是相同的；
# 如果找到了 0，那么将其与nums[p_0] 进行交换，并将 p_0向后移动一个位置。这样做是正确的吗？我们可以注意到，因为连续的 0 之后是连续的 1，因此如果我们将 00 与 nums[p 0] 进行交换，
# 那么我们可能会把一个 1 交换出去。当 p_0 < p_1时，我们已经将一些 1连续地放在头部，此时一定会把一个 1 交换出去，导致答案错误。
# 因此，如果 p_0 < p_1
# 那么我们需要再将 nums[i] 与 nums[p_1] 进行交换，其中i 是当前遍历到的位置，在进行了第一次交换后，nums[i] 的值为1，我们需要将这个 1 放到「头部」的末端。
# 在最后，无论是否有 p_0 < p_1
#  ，我们需要将 p0和 p1 均向后移动一个位置，而不是仅将 p0 向后移动一个位置。

class Solution:
    def sortColors(self, nums):
        n = len(nums)
        p0 = p1 = 0
        for i in range(n):
            if nums[i] == 1:
                nums[i], nums[p1] = nums[p1], nums[i]
                p1 += 1
            elif nums[i] == 0:
                nums[i], nums[p0] = nums[p0], nums[i]
                if p0 < p1:
                    nums[i], nums[p1] = nums[p1], nums[i]
                p0 += 1
                p1 += 1


# 75. 颜色分类.py